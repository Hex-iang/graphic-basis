# Assignment 3 implementation report
* Arthur: Hexiang Hu 301239910

## Basic Part
  1. Rayâ€sphere intersection and local reflectance:       [Achieved]
    * test command: raycast [-d | -u] 5

  2. Shadows:                                             [Achieved]
    * test command: raycast [-d | -u] 5 +s

  3. Reflections:                                         [Achieved]
    * test command: raycast [-d | -u] 5 +s +l

  4. Chess Board:                                         [Achieved]
    * test command: raycast [-d | -u] 5 +s +l +c

  5. Refraction:                                          [Achieved]
    * test command: raycast -u 5 +s +l +c +r
    * Note: since that in the default scene, there is no transparency setted, please do test this feature through user scene.
      * In the user scene, the transmission rate is set as 1.1 for each ball
    
  6. Diffuse Reflection:                                  [Achieved]
    * test command: raycast [-d | -u] +s +l +r +c +f
  7. Super Sampling:                                      [Achieved]
    * test command: raycast [-d | -u] +s +l +r +c +f +p

  8. Additional Features: Poisson Anti-aliasing 
    * an alternative way for super sampling
    * test command: raycast [-d | -u] +s +l +r +c +f +p +b 


## Bonus Part
  1. Render Scene With Chess Pieces on Chess Board         [Achieved]

    * Render 2 low-resolution chess pieces - single bounding box accelerated
      * test command: raycast -b 5 +s +l +r +c +p +f
      	* intersection test:	4294598454
      	* total time: 				114.276 secs (2 min)
      	* saved as: 					low-resolution-chess.bmp
    * Render all chess pieces 						 - single bounding box accelerated
      * test command: raycast -b 5 +s +l +r +c +p +f +w
      	* intersection test: 	74827272024
      	* total time:					1481.74 secs (20+ min)
    * Note: 
      * Since it will take a while to render the scene, I attached two image "low-resolution-chess.bmp" and "high-resolution-chess.bmp" in the zip file. Or you can try run the program. [Recommend to turn off the diffuse reflection - use command raycast -b 5 +s +l +r +c +f +p ]
      * I tried to render the high resolution image with all details on using naive method, it turns out that the result can not be rendered in 2 hours, so I finally gave up doing a computation time comparing with the single bounding box accerlerated version 
      * In the bonus scene, I also placed a mirror in the back to the chess, so as to have better vision to each side of every piece of chess

  2. Improve the intersection with some methods            [Achieved]
  	* test command: raycast -b 5 +s +l +r +c +p +a0				=> test non-accelerated version
  	* test command: raycast -b 5 +s +l +r +c +p +a1				=> test accelerated version
    * In my implementation, I adopt a single bounding volume method for each chess piece, which decrease largely to the intersection test made by the program. The detailed analysis is shown in the following section


### Bonus Question 2: intersection case study
* Intersection algorithm result
  * Intersection Number for _naive intersection_ :
	  1. chess_piece.smf (+a0                   max-step:5) [512 x 512]: 
      * intersection test: 79691776
      * intersection :     7752
      * total ray number : 262144
	  2. chess_piece.smf (+s +r +l +c +a0       max-step:5) [512 x 512]: 
      * intersection test: 201988240
      * intersection :     14692
      * total ray number : 679966
    3. chess_piece.smf (+s +r +l +c +f +p +a0 max-step:5) [512 x 512]: 
      * intersection test: 2775710000
      * intersection :     234637
      * total ray number : 9894188

  * Intersection Number _Single bounding box_ : 16432484
  	1. chess_piece.smf (+a1                   max-step:5) [512 x 512]:
  		* intersection test: 2788896
  		* intersection :		 7752
  		* total ray number : 262144
  	2. chess_piece.smf (+s +r +l +c +a1       max-step:5) [512 x 512]:
  		* intersection test: 6226224
  		* intersection :		 14692
  		* total ray number : 679966
  	3. chess_piece.smf (+s +r +l +c +f +p +a1 max-step:5) [512 x 512]:
  		* intersection test: 103667344
  		* intersection :		 235271
  		* total ray number : 9905950

* Analysis
	* With my simple bounding box algorithm, we could decrease a order of magnitudes from the number of ray-triangle intersection in naive version of algorithm. 

## Code Structure

* Project Folder
  * object.h            - base class for all shape primitive
  * box.hpp             - bounding box volume class
  * ray.hpp             - ray class
  * sphere.hpp          - sphere class
  * scene.h/.cpp        - rendering scene setting up
  * trace.h/.hpp        - ray tracing algorithm
  * matrix.hpp          - 4 by 4 matrix helper function
  * vector.hpp          - 3d vector helper function
  * image_util.h/.cpp   - image writing
  * chess.h/.cpp        - chess class for processing chess object
  * chessboard.hpp      - chess board class
  * triangle.hpp        - triangle class, triangle mesh class
  * global.h            - global macro and variable

## Notice: 

In this assignment, I made a dual compilable version to linux machine and mac os x. However, as mac os x does not support some stale glut functionality, I basically disabled the openGL display mode in the mac compilation. And instead, I made the mac version to write a image after the rendering process
